---
{{ ansible_managed | comment }}

# The url clients will connect to.
# Typically this will be a domain like:
#
# https://myheadscale.example.com:443
#
server_url: {{ headscale_server_url }}

# Address to listen to / bind to on the server
#
# For production:
listen_addr: {{ headscale_listen_addr }}

# Address to listen to /metrics and /debug, you may want
# to keep this endpoint private to your internal network
metrics_listen_addr: {{ headscale_metrics_listen_addr }}

# Address to listen for gRPC.
# gRPC is used for controlling a headscale server
# remotely with the CLI
# Note: Remote access _only_ works if you have
# valid certificates.
#
grpc_listen_addr: {{ headscale_grpc_listen_addr }}

# Allow the gRPC admin interface to run in INSECURE
# mode. This is not recommended as the traffic will
# be unencrypted. Only enable if you know what you
# are doing.
#
grpc_allow_insecure: {{ headscale_grpc_allow_insecure | bool }}

# The Noise section includes specific configuration for the
# TS2021 Noise protocol
noise:
  # The Noise private key is used to encrypt the traffic between headscale and
  # Tailscale clients when using the new Noise-based protocol. A missing key
  # will be automatically generated.
  private_key_path: {{ headscale_noise_private_key_path }}

# List of IP prefixes to allocate tailaddresses from.
# Each prefix consists of either an IPv4 or IPv6 address,
# and the associated prefix length, delimited by a slash.
# It must be within IP ranges supported by the Tailscale
# client - i.e., subnets of 100.64.0.0/10 and fd7a:115c:a1e0::/48.
# See below:
# IPv6: https://github.com/tailscale/tailscale/blob/22ebb25e833264f58d7c3f534a8b166894a89536/net/tsaddr/tsaddr.go#LL81C52-L81C71
# IPv4: https://github.com/tailscale/tailscale/blob/22ebb25e833264f58d7c3f534a8b166894a89536/net/tsaddr/tsaddr.go#L33
# Any other range is NOT supported, and it will cause unexpected issues.
prefixes:
  v4: {{ headscale_prefix_v4 }}
  v6: {{ headscale_prefix_v6 }}

  # Strategy used for allocation of IPs to nodes, available options:
  # - sequential (default): assigns the next free IP from the previous given IP.
  # - random: assigns the next free IP from a pseudo-random IP generator (crypto/rand).
  allocation: {{ headscale_prefix_allocation }}

# DERP is a relay system that Tailscale uses when a direct
# connection cannot be established.
# https://tailscale.com/blog/how-tailscale-works/#encrypted-tcp-relays-derp
#
# headscale needs a list of DERP servers that can be presented
# to the clients.
derp:
  server:
    # If enabled, runs the embedded DERP server and merges it into the rest of the DERP config
    # The Headscale server_url defined above MUST be using https, DERP requires TLS to be in place
    enabled: {{ headscale_derp_enabled | bool }}

    # Region ID to use for the embedded DERP server.
    # The local DERP prevails if the region ID collides with other region ID coming from
    # the regular DERP config.
    region_id: {{ headscale_derp_region_id }}

    # Region code and name are displayed in the Tailscale UI to identify a DERP region
    region_code: {{ headscale_derp_region_code }}
    region_name: {{ headscale_derp_region_name }}

    # Only allow clients associated with this server access
    verify_clients: {{ headscale_derp_verify_clients | bool }}

    # Listens over UDP at the configured address for STUN connections - to help with NAT traversal.
    # When the embedded DERP server is enabled stun_listen_addr MUST be defined.
    #
    # For more details on how this works, check this great article: https://tailscale.com/blog/how-tailscale-works/
    stun_listen_addr: {{ headscale_derp_stun_listen_addr }}

    # Private key used to encrypt the traffic between headscale DERP and
    # Tailscale clients. A missing key will be automatically generated.
    private_key_path: {{ headscale_derp_private_key_path }}

    # This flag can be used, so the DERP map entry for the embedded DERP server is not written automatically,
    # it enables the creation of your very own DERP map entry using a locally available file with the parameter DERP.paths
    # If you enable the DERP server and set this to false, it is required to add the DERP server to the DERP map using DERP.paths
    automatically_add_embedded_derp_region: {{ headscale_derp_automatically_add_embedded_derp_region | bool }}

    # For better connection stability (especially when using an Exit-Node and DNS is not working),
    # it is possible to optionally add the public IPv4 and IPv6 address to the Derp-Map using:
    ipv4: {{ headscale_derp_ipv4 }}
    ipv6: {{ headscale_derp_ipv6 }}
  # List of externally available DERP maps encoded in JSON
  urls: {{ headscale_derp_urls | to_json }}

  # Locally available DERP map files encoded in YAML
  #
  # This option is mostly interesting for people hosting
  # their own DERP servers:
  # https://tailscale.com/kb/1118/custom-derp-servers/
  #
  # paths:
  #   - /etc/headscale/derp-example.yaml
  paths: {{ headscale_derp_local_paths | default([]) | to_json }}

  # If enabled, a worker will be set up to periodically
  # refresh the given sources and update the derpmap
  # will be set up.
  auto_update_enabled: {{ headscale_derp_auto_update_enabled | bool }}

  # How often should we check for DERP updates?
  update_frequency: {{ headscale_derp_update_frequency }}

# Disables the automatic check for headscale updates on startup
disable_check_updates: {{ headscale_disable_check_updates | bool }}

# Time before an inactive ephemeral node is deleted?
ephemeral_node_inactivity_timeout: {{ headscale_ephemeral_node_inactivity_timeout }}

database:
  # Database type. Available options: sqlite, postgres
  # Please note that using Postgres is highly discouraged as it is only supported for legacy reasons.
  # All new development, testing and optimisations are done with SQLite in mind.
  type: sqlite

  # Enable debug mode. This setting requires the log.level to be set to "debug" or "trace".
  debug: {{ headscale_db_debug | bool }}

  # GORM configuration settings.
  gorm:
    # Enable prepared statements.
    prepare_stmt: true

    # Enable parameterized queries.
    parameterized_queries: true

    # Skip logging "record not found" errors.
    skip_err_record_not_found: true

    # Threshold for slow queries in milliseconds.
    slow_threshold: 1000

  # SQLite config
  sqlite:
    # Path to database file
    path: {{ headscale_db_path }}

    # Enable WAL mode for SQLite. This is recommended for production environments.
    # https://www.sqlite.org/wal.html
    write_ahead_log: true

    # Maximum number of WAL file frames before the WAL file is automatically checkpointed.
    # https://www.sqlite.org/c3ref/wal_autocheckpoint.html
    # Set to 0 to disable automatic checkpointing.
    wal_autocheckpoint: 1000

### TLS configuration
#
## Let's encrypt / ACME
#
# headscale supports automatically requesting and setting up
# TLS for a domain with Let's Encrypt.
#
# URL to ACME directory
acme_url: {{ headscale_acme_url }}

# Email to register with ACME provider
acme_email: {{ headscale_acme_email }}

# Domain name to request a TLS certificate for:
tls_letsencrypt_hostname: {{ headscale_tls_letsencrypt_hostname }}

# Path to store certificates and metadata needed by
# letsencrypt
# For production:
tls_letsencrypt_cache_dir: {{ headscale_tls_letsencrypt_cache_dir }}

# Type of ACME challenge to use, currently supported types:
# HTTP-01 or TLS-ALPN-01
# See: docs/ref/tls.md for more information
tls_letsencrypt_challenge_type: {{ headscale_tls_letsencrypt_challenge_type }}

# When HTTP-01 challenge is chosen, letsencrypt must set up a
# verification endpoint, and it will be listening on:
# :http = port 80
tls_letsencrypt_listen: {{ headscale_tls_letsencrypt_listen }}

## Use already defined certificates:
tls_cert_path: {{ headscale_tls_cert_path }}
tls_key_path: {{ headscale_tls_key_path }}

log:
  # Valid log levels: panic, fatal, error, warn, info, debug, trace
  level: {{ headscale_log_level }}

  # Output formatting for logs: text or json
  format: {{ headscale_log_format }}

## Policy
# headscale supports Tailscale's ACL policies.
# Please have a look to their KB to better
# understand the concepts: https://tailscale.com/kb/1018/acls/
policy:
  # The mode can be "file" or "database" that defines
  # where the ACL policies are stored and read from.
  mode: "{{ headscale_policy_mode }}"

  # If the mode is set to "file", the path to a
  # HuJSON file containing ACL policies.
  path: "{{ headscale_policy_path }}"

## DNS
#
# headscale supports Tailscale's DNS configuration and MagicDNS.
# Please have a look to their KB to better understand the concepts:
#
# - https://tailscale.com/kb/1054/dns/
# - https://tailscale.com/kb/1081/magicdns/
# - https://tailscale.com/blog/2021-09-private-dns-with-magicdns/
#
# Please note that for the DNS configuration to have any effect,
# clients must have the `--accept-dns=true` option enabled. This is the
# default for the Tailscale client. This option is enabled by default
# in the Tailscale client.
#
# Setting _any_ of the configuration and `--accept-dns=true` on the
# clients will integrate with the DNS manager on the client or
# overwrite /etc/resolv.conf.
# https://tailscale.com/kb/1235/resolv-conf
#
# If you want stop Headscale from managing the DNS configuration
# all the fields under `dns` should be set to empty values.
dns:
  # Whether to use [MagicDNS](https://tailscale.com/kb/1081/magicdns/).
  magic_dns: {{ headscale_dns_magic_dns | bool }}

  # Defines the base domain to create the hostnames for MagicDNS.
  # This domain _must_ be different from the server_url domain.
  # `base_domain` must be a FQDN, without the trailing dot.
  # The FQDN of the hosts will be
  # `hostname.base_domain` (e.g., _myhost.example.com_).
  base_domain: {{ headscale_dns_base_domain }}

  # Whether to use the local DNS settings of a node or override the local DNS
  # settings (default) and force the use of Headscale's DNS configuration.
  override_local_dns: {{ headscale_dns_override_local_dns | bool }}

  # List of DNS servers to expose to clients.
  nameservers:
    global:
      {{ headscale_dns_nameservers | default([]) | to_nice_yaml(indent=2) | indent(6) }}

    # Split DNS (see https://tailscale.com/kb/1054/dns/),
    # a map of domains and which DNS server to use for each.
      # foo.bar.com:
      #   - 1.1.1.1
      # darp.headscale.net:
      #   - 1.1.1.1
      #   - 8.8.8.8
    split:
      {{ headscale_dns_split | default({}) | to_nice_yaml(indent=2) | indent(6) }}


  # Set custom DNS search domains. With MagicDNS enabled,
  # your tailnet base_domain is always the first search domain.
  search_domains:
    {{ headscale_dns_search_domains | default([]) | to_nice_yaml(indent=2) | indent(4) }}

  # Extra DNS records
  # so far only A and AAAA records are supported (on the tailscale side)
  # See: docs/ref/dns.md
  #   - name: "grafana.myvpn.example.com"
  #     type: "A"
  #     value: "100.64.0.3"
  #
  #   # you can also put it in one line
  #   - { name: "prometheus.myvpn.example.com", type: "A", value: "100.64.0.3" }
  #
  extra_records:
    {{ headscale_dns_extra_records | default([]) | to_nice_yaml(indent=2) | indent(4) }}

  # Alternatively, extra DNS records can be loaded from a JSON file.
  # Headscale processes this file on each change.
  # extra_records_path: /var/lib/headscale/extra-records.json 
  extra_records_path: {{ headscale_dns_extra_records_path | default("")}}

unix_socket: {{ headscale_unix_socket }}
unix_socket_permission: {{ headscale_unix_socket_permission | to_json }}

{% if headscale_oidc_enabled | bool %}
oidc:
  # Block startup until IdP is healthy
  only_start_if_oidc_is_available: {{ headscale_oidc_only_start_if_available | bool }}

  # Core OIDC settings
  issuer: {{ headscale_oidc_issuer | quote }}
  client_id: {{ headscale_oidc_client_id | quote }}

  # One of: client_secret OR client_secret_path (omit empty)
{% if headscale_oidc_client_secret | length > 0 %}
  client_secret: {{ headscale_oidc_client_secret | quote }}
{% endif %}
{% if headscale_oidc_client_secret_path | length > 0 %}
  client_secret_path: {{ headscale_oidc_client_secret_path | quote }}
{% endif %}

  # Session/expiry behavior
  expiry: {{ headscale_oidc_expiry }}
  use_expiry_from_token: {{ headscale_oidc_use_expiry_from_token | bool }}

  # Scopes
  scope: {{ headscale_oidc_scope | to_json }}

  # Extra params to IdP authorize endpoint
  extra_params:
    {{ headscale_oidc_extra_params | default({}) | to_nice_yaml(indent=2) | indent(4) }}

  # Admission controls (optional)
  allowed_domains:
    {{ headscale_oidc_allowed_domains | default([]) | to_nice_yaml(indent=2) | indent(4) }}
  allowed_users:
    {{ headscale_oidc_allowed_users | default([]) | to_nice_yaml(indent=2) | indent(4) }}
  allowed_groups:
    {{ headscale_oidc_allowed_groups | default([]) | to_nice_yaml(indent=2) | indent(4) }}

  # PKCE
  pkce:
    enabled: {{ headscale_oidc_pkce_enabled | bool }}
    method: {{ headscale_oidc_pkce_method | quote }}
{% endif %}

logtail:
  # Enable logtail for this headscale's clients.
  enabled: {{ headscale_logtail_enabled | bool }}

# Enabling this option makes devices prefer a random port for WireGuard traffic.
randomize_client_port: {{ headscale_randomize_client_port | bool }}
